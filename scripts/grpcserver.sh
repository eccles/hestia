#!/bin/bash
#
# Generate boilerplate for GRPC Service or not as the case maybe.
#
# This is executed in a subdirectory so we must cd into the root of the
# repo
cd $( dirname $( dirname $0))

. scripts/source/log
. scripts/source/environment

log_info "Generate GRPC boilerplate for $*"
if [ $# -ne 2 ]
then
	log_info "Must be 2 arguments"
	exit 1
fi
NAME=$(basename $2)
UPPER=$(echo ${NAME} | tr '[:lower:]' '[:upper:]' )
LOWER=$(echo ${NAME} | tr '[:upper:]' '[:lower:]' )
FIRST=$(echo ${NAME} | cut -c1 | tr '[:lower:]' '[:upper:]')
REST=$(echo ${NAME} | cut -c2-| tr '[:upper:]' '[:lower:]' )
CAPITAL=${FIRST}${REST}

# If the first argument is 1 then GRPS server is enabled.
if [ $1 -eq 1 ]
then
	UNIMPLEMENTED=Unimplemented${CAPITAL}Server
else
	UNIMPLEMENTED=
fi
#
# service.go
cat >$2/service.go <<EOF
// Code generated by $0. DO NOT EDIT.
package ${LOWER}

import (
	"fmt"
	"os"
	"os/signal"
	"syscall"

	"github.com/eccles/hestia/pkg/logger"
	"github.com/eccles/hestia/pkg/service"
)

type loggerContextKey string

type Service struct {
	${UNIMPLEMENTED}
	cfg service.Config
}

func (s *Service) Run() error {
	
	logger := logger.New(
		os.Getenv("LOGLEVEL"),
        )
	defer logger.OnExit()

	if s.cfg.GRPCServerPort != "" {
		grpcServer, err := s.StartGRPCServer(&logger)
		if err != nil {
			return fmt.Errorf("start failure: %w", err)
		}
		defer grpcServer.GracefulStop()
	}

	logger.Info("Wait for termination signal")

	// wait here for termination signal
	sCh := make(chan os.Signal, 1)
	signal.Notify(sCh, syscall.SIGINT, syscall.SIGTERM)
	<-sCh

	// k8s is in charge now so undo handling of signals
	signal.Reset(syscall.SIGINT, syscall.SIGTERM)

	return nil
}
EOF

#
# grpcserver.go
if [ $1 -eq 1 ]
then
	cat >$2/grpcserver.go <<EOF
// Code generated by $0. DO NOT EDIT.
package ${LOWER}

import (
	"fmt"
	"net"

	"google.golang.org/grpc"
	"google.golang.org/grpc/reflection"

	"github.com/eccles/hestia/pkg/logger"
)

func (s *Service) StartGRPCServer(logger *logger.Logger) (*grpc.Server, error) {

	logger.Info("Start GRPCServer")
	grpcServer := grpc.NewServer()

	Register${CAPITAL}Server(grpcServer, s)
	reflection.Register(grpcServer)

	listen, err := net.Listen("tcp", ":"+s.cfg.GRPCServerPort)
	if err != nil {
		return nil, fmt.Errorf("listen ':%s' failure: %w", s.cfg.GRPCServerPort, err)
	}

	go func() {
		err = grpcServer.Serve(listen)
		if err != nil {
			panic("Failed to start")
		}
	}()

	return grpcServer, nil
}
EOF

else
	cat >$2/grpcserver.go <<EOF
// Code generated by $0. DO NOT EDIT.
package ${LOWER}

import (
        "errors"

        "google.golang.org/grpc"

	"github.com/eccles/hestia/pkg/logger"
)

var ErrGRPCDisabled = errors.New("GRPCServer is disabled")

func (s *Service) StartGRPCServer(logger *logger.Logger) (*grpc.Server, error) {
        return nil, ErrGRPCDisabled
}
EOF
fi
