#!/bin/bash
#
# Generate boilerplate for GRPC Service or not as the case maybe.
#
# This is executed in a subdirectory so we must cd into the root of the
# repo
cd $( dirname $( dirname $0))

. scripts/source/log
. scripts/source/environment

log_info "Generate GRPC boilerplate for $*"
if [ $# -ne 2 ]
then
	log_info "Must be 2 arguments"
	exit 1
fi
NAME=$(basename $2)
UPPER=$(echo ${NAME} | tr '[:lower:]' '[:upper:]' )
LOWER=$(echo ${NAME} | tr '[:upper:]' '[:lower:]' )
FIRST=$(echo ${NAME} | cut -c1 | tr '[:lower:]' '[:upper:]')
REST=$(echo ${NAME} | cut -c2-| tr '[:upper:]' '[:lower:]' )
CAPITAL=${FIRST}${REST}

# If the first argument is 1 then GRPS server is enabled.
if [ $1 -eq 1 ]
then
	UNIMPLEMENTED=${LOWER}API.Unimplemented${CAPITAL}Server
	REGISTER=${LOWER}API.Register${CAPITAL}Server
else
	UNIMPLEMENTED=
	REGISTER=
fi
#
# service.go
cat >$2/service.go <<EOF
// Code generated by $0. DO NOT EDIT.
package ${LOWER}

import (
	"fmt"

	"github.com/eccles/hestia/pkg/apis/widgets"
	"github.com/eccles/hestia/pkg/connections"
	"github.com/eccles/hestia/pkg/logger"
)

type loggerContextKey string

type Service struct {
	${UNIMPLEMENTED}

	LogLevel string
	logger   logger.Logger

	GRPCServerPort string

	connections.Connections
}

func (s *Service) Run() error {

	s.logger = logger.New(s.LogLevel)

	if s.GRPCServerPort != "" {
		grpcServer, err := s.StartGRPCServer()
		if err != nil {
			return fmt.Errorf("start failure: %w", err)
		}
		defer grpcServer.GracefulStop()
	}

	return s.Connect(&s.logger)
}
EOF

#
# grpcserver.go
if [ -n "${REGISTER}" ]
then
	cat >$2/grpcserver.go <<EOF
// Code generated by $0. DO NOT EDIT.
package ${LOWER}

import (
	"fmt"
	"net"

	"github.com/eccles/hestia/pkg/apis/widgets"

	"google.golang.org/grpc"
	"google.golang.org/grpc/reflection"
)

func (s *Service) StartGRPCServer() (*grpc.Server, error) {

	s.logger.Info().Msg("Start GRPCServer")
	grpcServer := grpc.NewServer()

	${REGISTER}(grpcServer, s)
	reflection.Register(grpcServer)

	listen, err := net.Listen("tcp", ":"+s.GRPCServerPort)
	if err != nil {
		return nil, fmt.Errorf("listen ':%s' failure: %w", s.GRPCServerPort, err)
	}

	go func() {
		err = grpcServer.Serve(listen)
		if err != nil {
			panic("Failed to start")
		}
	}()

	return grpcServer, nil
}
EOF

else
	cat >$2/grpcserver.go <<EOF
// Code generated by $0. DO NOT EDIT.
package ${LOWER}

import (
        "errors"

        "google.golang.org/grpc"
)

var ErrGRPCDisabled = errors.New("GRPCServer is disabled")

func (s *Service) StartGRPCServer() (*grpc.Server, error) {
        return nil, ErrGRPCDisabled
}
EOF
fi
