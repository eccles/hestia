#!/bin/bash
#
# Generate boilerplate for GRPC Service or not as the case maybe.
#
# This is executed in a subdirectory so we must cd into the root of the
# repo
cd $( dirname $( dirname $0))

. scripts/source/log
. scripts/source/environment

log_info "Generate GRPC boilerplate for $*"
if [ $# -ne 2 ]
then
	log_info "Must be 2 arguments"
	exit 1
fi
#
# Sort out all variations of servicename regarding capitalisation.
SERVICENAME=$(basename $2)
UPPER=$(echo ${SERVICENAME} | tr '[:lower:]' '[:upper:]' )
LOWER=$(echo ${SERVICENAME} | tr '[:upper:]' '[:lower:]' )
FIRST=$(echo ${SERVICENAME} | cut -c1 | tr '[:lower:]' '[:upper:]')
REST=$(echo ${SERVICENAME} | cut -c2-| tr '[:upper:]' '[:lower:]' )
CAPITAL="${FIRST}${REST}"

# If the first argument is 1 then GRPS server is enabled.
if [ $1 -eq 1 ]
then
	UNIMPLEMENTED="${LOWER}API.Unimplemented${CAPITAL}Server"
	REGISTER="${LOWER}API.Register${CAPITAL}Server"
else
	UNIMPLEMENTED=
	REGISTER=
fi
#
# service.go
cat >$2/service.go <<EOF
// Code generated by $0. DO NOT EDIT.
package ${LOWER}

import (
	"fmt"

	"github.com/eccles/hestia/pkg/apis/widgets"
	"github.com/eccles/hestia/pkg/connections"
	"github.com/eccles/hestia/pkg/logger"
)

type loggerContextKey string

type Service struct {
	${UNIMPLEMENTED}

	Logger logger.LoggerInterface

	GRPCServerPort string

	connections.Connections
}

func (s *Service) Run() error {

	var err error
	err = s.Logger.Open()
	if err != nil {
		return fmt.Errorf("logger start failure: %w", err)
	}
	defer s.Logger.Close()

	if s.GRPCServerPort != "" {
		grpcServer, err := s.StartGRPCServer()
		if err != nil {
			return fmt.Errorf("grpcserver start failure: %w", err)
		}
		defer grpcServer.GracefulStop()
	}

	return s.Connect(s.Logger)
}
EOF

#
# grpcserver.go - only if first argument to script is 1
if [ -n "${REGISTER}" ]
then
	cat >$2/grpcserver.go <<EOF
// Code generated by $0. DO NOT EDIT.
package ${LOWER}

import (
	"fmt"
	"net"

	"github.com/eccles/hestia/pkg/apis/widgets"

	grpc_middleware "github.com/grpc-ecosystem/go-grpc-middleware"
	grpc_validator "github.com/grpc-ecosystem/go-grpc-middleware/validator"
	"google.golang.org/grpc"
	"google.golang.org/grpc/reflection"
)

func (s *Service) StartGRPCServer() (*grpc.Server, error) {

	s.Logger.Info().Msg("Start GRPCServer")
	grpcServer := grpc.NewServer(
		grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
			grpc_validator.UnaryServerInterceptor(),
		)),
	)


	${REGISTER}(grpcServer, s)
	reflection.Register(grpcServer)

	listen, err := net.Listen("tcp", ":"+s.GRPCServerPort)
	if err != nil {
		return nil, fmt.Errorf("listen ':%s' failure: %w", s.GRPCServerPort, err)
	}

	go func() {
		err = grpcServer.Serve(listen)
		if err != nil {
			panic("Failed to start")
		}
	}()

	return grpcServer, nil
}
EOF

else
	# first argument to script is not 1
	cat >$2/grpcserver.go <<EOF
// Code generated by $0. DO NOT EDIT.
package ${LOWER}

import (
        "errors"

        "google.golang.org/grpc"
)

var ErrGRPCDisabled = errors.New("GRPCServer is disabled")

func (s *Service) StartGRPCServer() (*grpc.Server, error) {
        return nil, ErrGRPCDisabled
}
EOF
fi
