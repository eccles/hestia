#!/bin/bash
#
# Generate boilerplate for GRPC Service or not as the case maybe.
#
SERVICEDIR=$(pwd)
#env | grep GO | sort

# This is executed in a subdirectory so we must cd into the root of the
# repo
cd $( dirname $( dirname $0))

. scripts/source/log
. scripts/source/environment

log_info "Generate GRPC boilerplate for $*"
if [ $# -lt 2 ]
then
	log_info "Must be 2 arguments"
	exit 1
fi
if [ -z "${GOPACKAGE}" ]
then
	log_info "GOPACKAGE is undefined"
	log_info "This script must only be executed by 'go generate'"
	exit 1
fi
BASENAME=$2
#
# Sort out all variations of gopackage regarding capitalisation.
UPPER=$(echo ${BASENAME} | tr '[:lower:]' '[:upper:]' )
LOWER=$(echo ${BASENAME} | tr '[:upper:]' '[:lower:]' )
FIRST=$(echo ${BASENAME} | cut -c1 | tr '[:lower:]' '[:upper:]')
REST=$(echo ${BASENAME} | cut -c2-| tr '[:upper:]' '[:lower:]' )
CAPITAL="${FIRST}${REST}"

# If the first argument is 1 then GRPC service is enabled.
# If not equal to 1 then the GRPC Service is stubbed out.
if [ $1 -eq 1 ]
then
	UNIMPLEMENTED="${BASENAME}API.Unimplemented${CAPITAL}Server"
	REGISTER="${BASENAME}API.Register${CAPITAL}Server"
else
	UNIMPLEMENTED=
	REGISTER=
fi
#
# service.go
cat >${SERVICEDIR}/service.go <<EOF
// Code generated by $0 $*. DO NOT EDIT.
package ${GOPACKAGE}

import (
	"fmt"

	${BASENAME}API "github.com/eccles/hestia/pkg/apis/${BASENAME}"
)

type loggerContextKey string

// implments the ${BASENAME}API.${CAPITAL}Server interfacw
type Service struct {
	${UNIMPLEMENTED}

	// An interface as we may want to mock it out in tests.
	Logger LoggerInterface

	// A concrete implementation of a GRPC service.
	GRPC GRPCService
}

func (s *Service) Run() error {

	var err error

	err = s.Logger.Open()
	if err != nil {
		return fmt.Errorf("logger start failure: %w", err)
	}
	defer s.Logger.Close()

	err = s.StartGRPCService()
	if err != nil {
		return fmt.Errorf("grpcservice start failure: %w", err)
	}
	defer s.GRPC.Stop()

	return s.Connect()
}
EOF

#
# grpcserver.go - only if first argument to script is 1
if [ -n "${REGISTER}" ]
then
	cat >${SERVICEDIR}/grpcserver.go <<EOF
// Code generated by $0 $*. DO NOT EDIT.
package ${GOPACKAGE}

import (
	"fmt"
	"net"

	${BASENAME}API "github.com/eccles/hestia/pkg/apis/${BASENAME}"

	grpc_middleware "github.com/grpc-ecosystem/go-grpc-middleware"
	grpc_validator "github.com/grpc-ecosystem/go-grpc-middleware/validator"
	"google.golang.org/grpc"
	"google.golang.org/grpc/reflection"
)

// GRPCService represents an incoming connection i.e a server that handles GRPC messages
// sent from a client.
type GRPCService struct {
	Port string

	Server *grpc.Server
}

func (g *GRPCService) Stop() {
	g.Server.GracefulStop()
}

// StartGRPCService initialises the GRPC service structs generated in thee qpis
// package and starts the GRPC service.
func (s *Service) StartGRPCService() error {

	s.Logger.Info().Msg("Start GRPCService")
	grpcServer := grpc.NewServer(
		grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
			grpc_validator.UnaryServerInterceptor(),
		)),
	)

	${REGISTER}(grpcServer, s) // s is of type widgetsAPI.WidgetsServer
	reflection.Register(grpcServer)

	listen, err := net.Listen("tcp", ":"+s.GRPC.Port)
	if err != nil {
		return fmt.Errorf("listen ':%s' failure: %w", s.GRPC.Port, err)
	}

	s.GRPC.Server = grpcServer
	go func() {
		err = s.GRPC.Server.Serve(listen)
		if err != nil {
			s.Logger.Fatal().Err(err).Msg("Failed to start")
		}
	}()

	return nil
}
EOF
	exit 0
fi

# first argument to script is not 1
cat >${SERVICEDIR}/grpcserver.go <<EOF
// Code generated by $0 $*. DO NOT EDIT.
package ${GOPACKAGE}

import (
	"errors"
)

var ErrGRPCDisabled = errors.New("GRPCServer is disabled")

func (s *Service) StartGRPCService() error {
	return ErrGRPCDisabled
}
EOF
exit 0
